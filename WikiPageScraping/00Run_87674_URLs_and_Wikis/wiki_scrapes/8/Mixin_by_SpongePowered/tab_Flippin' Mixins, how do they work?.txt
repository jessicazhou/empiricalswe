[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <p>One of the criticisms I see levelled against Mixin from time to time is that it's too complicated or is just overkill for a particular job. The aim of this article is therefore to explain exactly how Mixin functions in order to allay any fears that it's overly complex - in fact I hope to show that it's simply <em>exactly as complex as it needs to be to do its job</em> - by explaining exactly what each part of the subsystem does and how it functions.</p>
<p>The aim here is to give those familiar with bytecode manipulation, and with ASM in particular, a rounded understanding of Mixin's core, to understand its lifecycle and the reasons for certain design decisions which may seem arcane at first glance.</p>
<blockquote>
<p>For the purposes of this article not becoming an un-navigable mess, I am going to assume a familiarity with Mixin's feature set, with the structure of Java classes and bytecode, and with ASM. This is a technical article and is really only suitable for those interested in the inner workings and lifecycle of Mixin. I have done my best to write in plain english, but I'm making no promises that this will make any sense if you don't already have a good understanding of the previously mentioned topics.</p>
</blockquote>
<h1>
<a aria-hidden="true" class="anchor" href="#1-the-principle" id="user-content-1-the-principle"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>1. The Principle</h1>
<p>Ultimately, at its core, Mixin takes two sets of bytecode, that of a target class and a mixin "class", and merges them together. ASM provides various ways to do this, but quite honestly anyone who has used ASM for more than five minutes will realise a vital truth:</p>
<ul>
<li>Merging bytecode with ASM is trivially easy</li>
</ul>
<p>In fact it's so easy that we can copy a method from one class to another with 8 lines of ASM:</p>
<div class="highlight highlight-source-java"><pre><span class="pl-smi">ClassNode</span> source <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ClassNode</span>();
<span class="pl-smi">ClassNode</span> dest <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ClassNode</span>();
<span class="pl-k">new</span> <span class="pl-smi">ClassReader</span>(sourceBytes)<span class="pl-k">.</span>accept(source);
<span class="pl-k">new</span> <span class="pl-smi">ClassReader</span>(destBytes)<span class="pl-k">.</span>accept(dest);
source<span class="pl-k">.</span>methods<span class="pl-k">.</span>stream()<span class="pl-k">.</span>filter(m <span class="pl-k">-</span><span class="pl-k">&gt;</span> m<span class="pl-k">.</span>name<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>))<span class="pl-k">.</span>forEach(dest<span class="pl-k">.</span>methods<span class="pl-k">::</span>add);
<span class="pl-smi">ClassWriter</span> cw <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ClassWriter</span>(<span class="pl-c1">0</span>);
dest<span class="pl-k">.</span>accept(cw);
<span class="pl-k">return</span> cw<span class="pl-k">.</span>toByteArray();</pre></div>
<p>This isn't even the easiest or most efficient way, just the shortest.</p>
<p>Obviously we know that this will only work with a carefully crafted source method, and that things will immediately explode if a conflicting method already exists for example. Since ASM doesn't check that what we're doing is valid, it merely gives us tools to manipulate the underlying class bytes, it's quite easy for this to go wrong.</p>
<p>But assuming we can check the obvious preconditions, which surely must be pretty easy to check, <strong>where does all the complexity come from</strong>?</p>
<p>The answer is that Mixin undertakes a lot of work to ensure that incoming mixin code is both sane and correct, and also provides for functionality which extends far beyond the bounds of a single target class. The fact is that</p>
<ul>
<li>Merging bytecode with ASM <strong>in a safe and reliable manner</strong> is nontrivially hard</li>
</ul>
<p>The following sections take a look at some of the features Mixin provides, and the problems it tries to solve and explains how it attempts to solve them. It does this largely by taking a walk through Mixin's lifecycle and explaining what it does and how it does it.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#2-the-feature-set" id="user-content-2-the-feature-set"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2. The Feature Set</h1>
<p>Merging bytecode in a dumb way is fine if the mixin author takes full responsibility for their actions, understands the inner workings of the JVM, and can carefully craft the incoming mixin to not break any of the rules. However one of the main goals of Mixin has always been a kind of Transformer Hippocratic Oath to "do no harm". If the mixin is invalid, Mixin should fail-fast and ideally fail with a meaningful error. The onus is then on the mixin author to <em>write valid mixins</em> and on Mixin to turn <em>valid mixins</em> into <em>valid bytecode</em> in the target. We also want to provide features to mixin authors which allow them to write powerful mixins in a straightforward way.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#21-target-class-scope" id="user-content-21-target-class-scope"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2.1 Target Class Scope</h2>
<p>One of the features of Mixin which leads to the most scaffolding is supporting operations which reach outside of the target class, in particular operations which reference superclasses or members added by other mixins to the same class.</p>
<p>One of the most complex aspects of validating hierarchy operations is accessing fields and methods on a superclass of a target class which are themselves added by another mixin, by virtue of having the derived mixin extend the supermixin. This is such a complex topic that it already has <a href="https://github.com/SpongePowered/Mixin/wiki/About-Hierarchy-Validation-in-Mixins">its own article</a>.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#22-soft-operations" id="user-content-22-soft-operations"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2.2 "Soft" Operations</h2>
<p>Thanks to the workings of the JVM, there are some things we can get away with in mixins which would never be valid Java, but are valid bytecode. Supporting these operations requires defining a "soft" syntax for these operations which can be transformed into real code at application time. Examples include "soft-implementing" interfaces, defining <em>Intrinsic Proxies</em>, and merging methods which have conflicting signatures but differing return types.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#23-awareness-of-other-mixins" id="user-content-23-awareness-of-other-mixins"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2.3 Awareness of Other Mixins</h2>
<p>Mixins are designed with awareness of other mixins in mind. Negotiation between mixins is provided by a simple priority system, a more complex <em>companion plugin</em> system, and by contract features such as the <code>@Final</code> annotation.</p>
<p>All mixins provided by all consumers are applied to a particular target class in one pass, so that mixins interact with each other in predictable and ultimately deterministic ways.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#24-fail-fast-or-fail-safe" id="user-content-24-fail-fast-or-fail-safe"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2.4 Fail Fast or Fail Safe</h2>
<p>Ultimately, we never want to end up in a situation where we allow "bad" bytecode to make it all the way into the ClassLoader. We want our mixins to fail-fast in a predictable way - ideally providing as much information as possible, or at the very least to "fail safe" in that injected code is always valid or just remains wholly un-merged.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#25-compatibility-and-environmental-awareness" id="user-content-25-compatibility-and-environmental-awareness"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2.5 Compatibility and Environmental Awareness</h2>
<p>As well as the core functionality of mixin which addresses the notion of <a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins#2-resolving-the-identity-crisis---defining-the-obfuscation-boundary">obfuscation boundaries</a> and different obfuscation contexts, the actual transformations undertaken by mixin should always take into account actions by other class transformers in the environment at run time. This awareness contributes to the previous goal: if a transformer changes a class in a way we don't expect, we want to detect this situation and again, <em>fail fast or fail safe</em>.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#25-efficiency" id="user-content-25-efficiency"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>2.5 Efficiency</h2>
<p>We want to achieve all of the above in the most efficient way possible. Obviously there are trade-offs with speed and memory usage, and in general Mixin will err on the side of using more memory as an opportunity to gain more speed.</p>
<p>In recent versions of Mixin I have undertaken to profile the different parts of the mixin process, and as expected the vast majority of time is actually spent in side-loading and transforming classes (see the sections on ClassInfo below) which ultimately would need to happen anyway. In general, the core of the Mixin processor is acceptably fast given its capabilities.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#3-the-lifecycle" id="user-content-3-the-lifecycle"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3. The Lifecycle</h1>
<p>So now we know what we want to achieve, now it's time to dive into the guts of the transformer and see how the different classes interact. This discussion is going to discuss the role of different classes in Mixin's core, so I will take care to link to the relevant source code wherever possible.</p>
<p>I will skip over platform-specific actions in the subsytem and talk only about the Mixin process itself. This is mainly because the platform-specific handlers are resposible for low-level marshalling of jars, tweakers and remapping agents and the whole topic is frankly pretty dull and doesn't add to the understanding of Mixin itself, so I won't digress.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#31-startup" id="user-content-31-startup"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.1 Startup</h2>
<p>Mixin as a subsystem needs to start up somewhere, and most often this is initiated by one or more agents. All consumers in the environment will interact with a single instance of the Mixin subsystem, and thus the party responsible for bootstrapping has little bearing on the operation of Mixin, other than which version is in use.</p>
<p>Besides registering the relevant companion objects, the main task undertaken by consumers is to register their mixin configuration files with the subsystem itself.</p>
<p>It comes as a surprise to some that Mixin requires mixins to be added to a configuration file. <em>"Why"</em> - they ask - "<em>can mixin not just scan for mixin classes in a jar, the same way we scan for mods?</em>" To which the answer is that the main reason is speed, scanning jars is quite expensive and using a configuration file means we can also specify a lot of important corollary information too. It also means that mixins can exist in the jar which are not applied, or are selectively applied by utilising a companion plugin.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_00.png"/></p>
<p>When configs are added they are immediately parsed by being internally deserialised to <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a> instances. Parsing the config determines the following attributes:</p>
<ul>
<li>
<p>The required compatibility level - we can fail fast if the required level is unavailable</p>
</li>
<li>
<p>The required mixin subsystem version - again, fail fast if the version in use is too old</p>
</li>
<li>
<p>The desired <em>phase</em> for the config - more on phases later</p>
</li>
</ul>
<p>The list of mixins in the config is deserialised but not parsed, the mixins in the config are not parsed until the config itself is activated by the start of the phase.</p>
<p>As well as gathering configs, Mixin registers its own <em>Class Transformer</em> which then becomes the entry point for most of the rest of Mixin's functionality.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#32-beginning-a-phase" id="user-content-32-beginning-a-phase"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2 Beginning a Phase</h2>
<p>First of all, let's answer the question "<em>Why does Mixin have phases at all?</em>"</p>
<p>Before we begin applying mixins, as we shall discover below, we actually need to gather quite a lot of information. Mixins which depend on supermixins or upon transformations made by other class transformers need to know that the supermixins are available, that their target class(es) are as expected, etc. This means that before we begin applying mixins, we need to know about all the mixins we are planning to apply.</p>
<p>Normally this is fine. Mixins are pumped through the transformer chain just like regular classes, everything is loaded and processed in one go, and then we are free to apply the mixins as the target classes pass through the live transformer chain in the ClassLoader.</p>
<p>However, since it may be desirable - especially for other subsystem-level technologies, such as Sponge - to apply mixins to other parts of the loader infrastructure. The simple solution would seem to be "<em>just load the mixins earlier</em>". The problem is that certain mixins are going to rely on being transformed by - for example - the <em>Side Transformer</em> or in certain cases the deobfuscating transformer. At the very start of the game's lifecycle, these transformers are not active since they form part of the framework we wish to transform!</p>
<p>The answer is the introduction of <em>phases</em>. Thus the <code>PREINIT</code> phase comprises mixins which need to mix into infrastructure classes, which need not rely on the transformer chain being completed. Later <code>DEFAULT</code> phase mixins are then loaded once the transformer chain is substantively complete and the game is in its "ready to be loaded" state.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#321-selecting-configs" id="user-content-321-selecting-configs"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2.1 Selecting Configs</h3>
<p>We already know which configs wish to participate in which phase, so the start of a phase is triggered by the first class to pass through the transformer chain when the criteria for beginning that phase are met. Thus, on entry, one of the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTransformer.java#L451">MixinTransformer's first tasks</a> is to check whether a new phase has begun, and <em>select</em> the configs for that phase.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_01.png"/></p>
<p>Configs from previous phases are always retained, at the start of a phase, configs for that phase are cherry-picked from the environment's list of available phases and then sorted by priority into a pending list</p>
<p><a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a>s perform some initial self-configuration upon being selected:</p>
<ul>
<li>The config's <em>companion plugin</em> (if specified) is instantiated</li>
<li>The config's <em>reference map</em> is loaded and parsed</li>
</ul>
<p>Configs which fail selection are removed from the pending list and are not processed further.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#322-preparing-configs" id="user-content-322-preparing-configs"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2.2 Preparing Configs</h3>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_02.png"/></p>
<p><a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a>s which pass selection are then prepared. Preparation can be quite a lengthy operation because the mixins in the config themselves must be loaded from disk and parsed.</p>
<p>Each <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a> contains 3 discrete mixin sets, <em>server</em>, <em>client</em> and <em>common</em> mixins, with the <em>common</em> mixins being parsed first and then either the <em>client</em> or <em>server</em> sets being parsed next depending on the detected <strong>side</strong>.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3221-parsing-mixins" id="user-content-3221-parsing-mixins"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2.2.1 Parsing Mixins</h4>
<p>During the prepare stage, the mixins in the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">config</a> are loaded from disk, each Mixin is parsed into a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> struct which handles the initial parsing of the mixin, and acts as storage for all the generated metadata.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_03.png"/></p>
<p>If the mixin bytecode is successfully loaded, the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> proceeds to gather the required information for the mixin:</p>
<ul>
<li>
<p>The mixin <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L162">State</a> is initialised. The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L162">State</a> is a struct used to hold the mixin bytecode and unvalidated details parsed from the mixin class. <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L162">State</a> is maintained as a separate struct within the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> for validation purposes and as scaffolding to facilitate hot-swapping later in the application lifecycle.</p>
</li>
<li>
<p>A <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> for the mixin is created.</p>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> is used extensively throughout Mixin. <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> is used to access and store class metadata without using reflection (which would trigger a class load) by side-loading the class and passing it manually through the transformer chain.</p>
<p><a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> stores similar information to the Java <code>Class</code> object, but with a focus on information required by Mixin. To this end, <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> is mutable, keeping track of which mixins target a particular class and tracking changes which are made by mixins so that the changes are visible to other mixins.</p>
<p>Classes side-loaded for the purposes of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> are passed through a subset of the transformer chain known as the <em>delegation list</em>. The <em>delegation list</em> is updated when a new phase is entered, and deliberately excludes any transformers known to be re-entrant, and the mixin transformer itself.</p>
<p>Whilst the performance impact of side-loading seems significant, in practice the most expensive operation tends to be the transformers themselves, since the second time the bytecode is loaded "for real" it is usually already present in memory and does not exact any measurable performance cost.</p>
</blockquote>
<ul>
<li>
<p>The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L452">SubType</a> of the mixin is initialised. The criteria for determining the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L452">SubType</a> are straightforward:</p>
<ul>
<li>
<p>If the mixin is a <code>class</code>, it is a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L526">Standard Mixin</a></p>
</li>
<li>
<p>If the mixin is an <code>interface</code> and contains only <em>accessor methods</em> then it is an <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L601">Accessor Mixin</a></p>
</li>
<li>
<p>Otherwise it is an <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L571">Interface Mixin</a></p>
</li>
</ul>
</li>
<li>
<p>The mixin <em>target classes</em> are then parsed from the <code>@Mixin</code> annotation. Public targets specified as class literals are parsed first, followed by soft targets specified as strings.</p>
<p>Each target is first checked for eligibility against the mixin config's <em>companion plugin</em> (if any) and a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> is then fetched for each successful target. If a target is unavailable, the preparation phase will fail-fast at this point.</p>
<p>Targets which are successfully discovered are checked against the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L452">SubType</a> for eligibility (eg. to make sure an interface mixin isn't targetting a class).</p>
</li>
</ul>
<h4>
<a aria-hidden="true" class="anchor" href="#3222-completing-config-preparation" id="user-content-3222-completing-config-preparation"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2.2.2 Completing Config Preparation</h4>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_02.png"/></p>
<p>As each <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> completes the parsing phase, the parent <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a> ingests the target classes into its own local set of targets, this allows the config to determine, for any given target class, whether it has any mixins to apply.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#323-validating-configs" id="user-content-323-validating-configs"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2.3 Validating Configs</h3>
<p>Preparing the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a>s generates the universe of configs and mixins for the phase, at this point we know that all mixins for the phase have been successfully parsed and all intended <em>target classes</em> are known.</p>
<p>At this stage, a validation pass is made which visits each <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a> and causes it to trigger validation of its child <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a>s.</p>
<p>The validation pass for the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> visits the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L162">State</a> which has retained the initial <code>ClassNode</code> created during the parsing phase. The <em>State</em> performs checks on the mixin to ensure that it is sane against its parsed <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L452">SubType</a> and <em>target classes</em>:</p>
<ul>
<li>
<p>A <em>MixinPreProcessor</em> is constructed and the <code>prepare</code> action is executed, followed by a <code>conform</code> for each <em>target class</em> (see the section later on conforming). This has the effect of decorating each <em>target class <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a></em> with conformed injector methods. This is done at an early stage so that injector handlers can be properly discovered by all other mixins in the stage during the application phase.</p>
</li>
<li>
<p>Basic sanity checks are made by the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L452">SubType</a>. One of the main checks made is to ensure that the direct superclass of the mixin appears in the superclass hierarchy of each <em>target class</em>. This necessitates recursively navigating the class hierarchy using <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> and may trigger further class side-loading in order to populate the additional metadata required at this stage. For <em>Interface Mixins</em> and <em>Accessor Mixins</em>, a more basic check is performed.</p>
</li>
<li>
<p>Basic sanity checks are made by the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java#L162">State</a> itself.</p>
</li>
<li>
<p>Inner classes in the mixin are visited and internally stored so they can later be processed. More details in later sections.</p>
</li>
</ul>
<p>If a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> fails the validation pass, an error is logged and the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> is removed from the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a>'s pending mixin set.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#324-activating-configs" id="user-content-324-activating-configs"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.2.4 Activating Configs</h3>
<p><a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a>s which survive the preparation process are added to the transformer's active collection of configs, which is then re-sorted to ensure that configs maintain priority order.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#33-applying-mixins" id="user-content-33-applying-mixins"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3 Applying Mixins</h2>
<h3>
<a aria-hidden="true" class="anchor" href="#331-initial-steps" id="user-content-331-initial-steps"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.1 Initial Steps</h3>
<p>The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTransformer.java">mixin transformer</a> performs additional duties to simply applying mixins to target classes. Since some classes need to be generated at runtime, the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTransformer.java">MixinTransformer</a> first delegates to any registered <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ext/IClassGenerator.java">IClassGenerator</a>s if the incoming bytecode is <code>null</code> - implying that the specified class needs to be fabricated per the general contract of class transformers.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3311-inner-class-generator" id="user-content-3311-inner-class-generator"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.1.1 Inner Class Generator</h4>
<p>Inner classes in mixins have to be handled quite delicately. It's important to note that inner classes aren't really particularly <em>inner</em> from the JVM's point of view, and a lot of the functionality afforded inner classes is simply syntactic sugar for package-private scaffolding created by the compiler to create the illusion of inner-ness.</p>
<p>This means that for inner classes, the synthetic scaffolding needs to be carefully reconstructed for each mixin target class, as does the inner class itself. Thus if a particular mixin <code>MixinFoo</code> has an inner class <code>MixinFoo$Baz</code> and targets two classes <code>com.home.Foo</code> and <code>com.home.Bar</code>, two copies of the inner class need to be made: one for each target.</p>
<p>I handle this situation at application time by conforming the class reference to the target and appending a unique identifier (to avoid conflicts between multiple mixins which just happen to have the same inner class name!). Thus our conformed class names will be <code>com.home.Foo$Baz$abcdef0123</code> and <code>com.home.Bar$Baz$defecdb4567</code>.</p>
<p>Each unique name can be easily reverse-inflected via an internal map to a particular target and source class, and thus is is the task of the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/InnerClassGenerator.java">InnerClassGenerator</a> to synthesise the bytecode for the conformed inner class by reading the original bytecode and transforming references to the mixin (the original outer class) to the desired target class. Note that access transformations are not necessary since any "private" members will have synthetic, package-private accessors to simulate the original inner-class behaviour.</p>
<p>Note that for <em>pure synthetic inner classes</em> we don't need to do this if the class is static, since currently the only source of pure synthetic inner classes is for the purposes of switch lookups. For these classes we simply pass-through the class bytecode as-is, in order to reduce the processing burden. This is handled by the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinPostProcessor.java">MixinPostProcessor</a> instead.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3312-args-class-generator" id="user-content-3312-args-class-generator"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.1.2 Args Class Generator</h4>
<p>The other class generator currently in employ is the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/invoke/arg/ArgsClassGenerator.java">ArgsClassGenerator</a> which is used to synthesise subclasses of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/invoke/arg/Args.java">Args</a> for use in <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/ModifyArgs.java">ModifyArgs</a> injectors.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#332-preparing-mixins-for-application" id="user-content-332-preparing-mixins-for-application"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.2 Preparing Mixins for Application</h3>
<p>For each incoming candidate class, <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a>s in the transformer's active set are visited to check whether they have any available mixins for the specified class. Remember from above that each <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a> maintains an internal hit list of target classes it has mixins for, and thus the process of selection is very fast.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_04.png"/></p>
<p>Each <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinConfig.java">MixinConfig</a> contributes eligible mixins to a <code>TreeSet</code> which intrinsically sorts the mixins by <code>priority</code> since <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> implements <code>Comparable&lt;MixinInfo&gt;</code> in order that mixin <code>priority</code> describes the natural order of the mixins.</p>
<p>If any eligible mixins are offered for the target, processing continues and an <code>ClassNode</code> is created for the incoming target class and is wrapped in a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/TargetClassContext.java">TargetClassContext</a> for marshalling through the rest of the pipeline. The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> for the target is also retrieved from the metadata pool, having been created earlier during the validation phase, and is thus pre-decorated with conformed members from declaring mixins.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3321-creating-the-applicator-and-pre-processing-mixins" id="user-content-3321-creating-the-applicator-and-pre-processing-mixins"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.2.1 Creating the Applicator and Pre-Processing Mixins</h4>
<p>The first stage in creating the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinApplicatorStandard.java">mixin applicator</a> is to pre-process the eligible mixins ready for application. This process blends the two contexts of the mixins themselves (in the form of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinInfo.java">MixinInfo</a> instances) and the <em>target class</em> (in the form of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/TargetClassContext.java">TargetClassContext</a>) storing the intermediate transformations in a resulting <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTargetContext.java">MixinTargetContext</a> object. <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTargetContext.java">MixinTargetContext</a> therefore represents a <strong>mixin</strong> in the context of a specific <strong>target</strong> as it passes through the <strong>applicator</strong>.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_05.png"/></p>
<p>The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinPreProcessorStandard.java">pre-processor</a> performs work in three stages to produce the required <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTargetContext.java">MixinTargetContext</a>:</p>
<ul>
<li>
<p><strong>Prepare</strong>
First prepares the mixin class in non-context-specific ways, for example stripping the prefixes from shadow methods and soft-implementing methods. These changes decorate the underlying <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> for the mixin so that renamed methods can be tracked.</p>
</li>
<li>
<p><strong>Conform</strong>
The <em>conforming</em> process is a target-context-specific action which prepares <em>unique</em> methods in the mixin (injector handlers, and any methods explicitly decorated with <code>@Unique</code>) by giving them names which are guaranteed to be unique within the target class hierarchy. Since this process is deterministic within the context of a given target, we can guarantee that the decorated names generated at this stage will match the conformed names generated in the validation pass performed earlier.</p>
</li>
<li>
<p><strong>Attach</strong>
The <em>attach</em> process is the most involved pre-processor step, and can be thought of as <em>specialising</em> the mixin to its target. It handles each type of method and field differently and thus has multiple responsibilities to discharge:</p>
<ul>
<li>
<p>For shadow methods and fields, it ensures that the shadow target exists in the target class</p>
</li>
<li>
<p>For <code>@Overwrite</code> methods it ensures that the target exists</p>
</li>
<li>
<p>For <code>@Unique</code> methods, it handles renaming private methods to avoid clashing with members in the target, and raises an error if public methods conflict</p>
</li>
<li>
<p>For every member, it decides whether the member should remain in the mixin in order to be applied to the target, or discarded because it is not required. For example shadows are discarded after verification and are instead registered with the target context so that they can be visited later.</p>
</li>
</ul>
<p>Once <em>attach</em> is completed, only members which need to be merged into the target remain present in the mixin, and all members have been conformed to their final signature ready for application.</p>
</li>
</ul>
<p>It's important to note that many of the actions taken during the preprocessing stage decorate the metadata counterparts of the mixin members in the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a>, facilitating actions later in the application process. For example, conformed injector methods can be overridden in derived mixins, but doing so requires a way of communicating the conformed name to the derived mixin, which might - thanks to the magic of classloading - actually get applied before the superclass counterpart. It is for this reason that the <em>conform</em> process is run during the validation stage, in order to fully populate this required metadata. Members in the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> can be discovered by both their original name and their conformed name, facilitating later calls to <code>isRenamed()</code> to determine the renaming state. This propagation of renaming also applies to prefixed <em>shadow</em> and <em>soft-implements</em> members, which may be over-ridden or called in derived mixins, and will need to know the relevant conformed name in order to have those calls transformed.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#333-applying-mixins" id="user-content-333-applying-mixins"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.3 Applying Mixins</h3>
<p>After the preprocessing stage, a sorted list (in <code>priority</code> order) of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTargetContext.java">MixinTargetContext</a>s exists in the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinApplicatorStandard.java">applicator</a>, the applicator then proceeds to apply the prepared mixins to the target class.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_06.png"/></p>
<p>Application of mixins proceeds in three stages, visiting mixins in their <code>priority</code> order.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3331-main-application-stage" id="user-content-3331-main-application-stage"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.3.1 Main Application Stage</h4>
<p>The <strong>Main</strong> application stage processes the majority of the mixin application logic, the business of taking the prepared mixin code and merging it into the <em>target class</em>. This stage comprises the following tasks:</p>
<ul>
<li>
<p><strong>Merging and applying the <em>generic signature</em></strong> of the mixin with the target class. This takes the form of blending declared signature elements on the mixin with declared elements on the target class. This is handled by <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/util/ClassSignature.java">ClassSignature</a> structs which are lazily evaluated against the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> metaobjects of the mixins and the <em>target class</em>.</p>
</li>
<li>
<p><strong>Merging <em>interfaces</em> declared on the mixins</strong> into the target class. Effectively adding an <code>implements</code> clause for each implementation declared on the mixins.</p>
</li>
<li>
<p><strong>Merging <em>class attributes</em></strong> such as class version and source file. This is done so that if, for example, the target class was compiled with Java 6 but the mixin usese Java 8 files, the output class has the correct major.minor version.</p>
</li>
<li>
<p><strong>Merging <em>annotations</em></strong> at the class level. Some annotations are discarded (for example the <code>@Mixin</code> annotation itself, whilst most others are merged onto the target.</p>
</li>
<li>
<p><strong>Merging <em>fields</em></strong> from the mixin into the target. Most fields are simply added to the target directly, shadows having been already discarded at the preparation stage. Annotations from shadow fields are merged however.</p>
</li>
<li>
<p><strong>Merging <em>methods</em></strong> from the mixin. This is the most involved step since methods require specialisation before merging, and the applicator also has to respect some other contractual obligations established by mixin.</p>
<p>As each method is processed it is <em>transformed</em>, this transformation process is handled by the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/MixinTargetContext.java">MixinTargetContext</a> and broadly consists of walking through each opcode in the mixin method and changing references to the mixin class (for example method and field accesses) into references to the new target class.</p>
<p>For methods and fields outside of the target class, the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> is used to lookup the relevant member, which may cause additional class side-loading if new classes need to be inspected. This is where earlier renames are applied to the actual calls to those members in the mixin.</p>
<p><em>Type casts</em> and method and field accesses  in the mixin also get some special handling with respect to supermixins. Any references to a supermixin within the scope of the mixin code will be transformed to the <em>target</em> of <em>that</em> mixin *in the context of the current target. To see how this works it's easier to consider a simple example:</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_06a.png"/></p>
<p>In this example, we have 3 mixins which target 2 classes each, respecting the hierarchy rules. <code>MixinZ</code> accesses a field <code>F</code> in <code>MixinX</code>. When <code>MixinZ</code> is applied to class <code>C</code>, the field access is transformed to <code>A.F</code> because <code>MixinZ</code> <em>in the context of target</em> <code>C</code> has superclass <code>A</code>. Likewise, in the context of target <code>L</code>, the field is transformed to target <code>J.F</code>. This is the underlying reason for the importance of <a href="https://github.com/SpongePowered/Mixin/wiki/About-Hierarchy-Validation-in-Mixins">hierarchy traversal</a> in both validation and in later stages of mixin specialisation.</p>
<p>It is also sometimes desirable in mixin code to type-cast the mixin to a known target, this results in a cast via <code>Object</code> because the Java compiler does not allow a direct cast to a <code>class</code> which it "knows" in advance will fail. So we will often see code such as <code>((TargetClass)(Object)this).somePublicMethod()</code>. Mixin detects and removes these double-casts for efficiency, meaning the resulting code has equivalent efficiency to simply calling <code>this.somePublicMethod()</code>.</p>
<p>Once the transformation of the method code is complete, the applicator continues the job of merging the method into the target</p>
<ul>
<li>
<p>In general, methods are expected to displace their targets, unless the target was already merged by another mixin and was decorated with <code>@Final</code>, implying that further overwrite operations are not permitted. Other <code>@Overwrite</code> methods which displace previous overwrites merely log a warning message.</p>
<p>There's also always the possibility that the method being merged is a <em>synthetic bridge</em> method in both targets. If this is the case, the bridges are compared for equivalence. If the bridges match then they are merged, otherwise an error is raised.</p>
</li>
<li>
<p><code>@Intrinsic</code> methods are also handled differently, in that they may be required to displace their target if the <code>displace</code> property is true. Otherwise they are simply skipped or merged depending on the presence or absence of their target.</p>
</li>
<li>
<p>Merged methods are also contributed to the target <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> at the point they are merged.</p>
</li>
</ul>
</li>
<li>
<p><strong>Merging <em>initialisers</em></strong> from the mixin. Initialisers are one of the more tricky aspects of merging mixins because constructors in Java classes are a Frankenstein's Monster of different parts of the original class. Compiled constructors can contain:</p>
<ul>
<li>
<p>The original constructor code, including explicit or implicit calls to the superconstructor.</p>
</li>
<li>
<p>Field initialisers from the class.</p>
</li>
<li>
<p>Instance initialisers from the class.</p>
</li>
<li>
<p>Initialisation code for synthetic aspects of the class, for example references to the outer class to a synthetic field.</p>
</li>
</ul>
<p>Because compiled constructors are such a mess of different parts, mixin limits the functionality afforded to the merging of initialisers. Where possible, field initialisers are detected by a nave line-number-based algorithm and the detected initialiser ranges are merged into constructors in the target.</p>
<p>The static initialiser is simply appended to the static initialiser of the target.</p>
</li>
</ul>
<p>Once the <strong>Main</strong> application stage is completed, all mixins for the class are fully merged with the target. The applicator then makes two further passes over the merged code in order to process <a href="https://github.com/SpongePowered/Mixin/wiki/Advanced-Mixin-Usage---Callback-Injectors">injectors</a>:</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3332-pre-injection-application-stage" id="user-content-3332-pre-injection-application-stage"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.3.2 Pre-Injection Application Stage</h4>
<p>Since all mixin content is now present in the target class. Injectors can be visited to determine which methods need to be modified and to discover their target opcodes in the candidate methods.</p>
<p>Each method is visited and inspected for any valid injection opcodes which are parsed out into <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionInfo.java">InjectionInfo</a> structs. The heavy lifting is handled by the base class  <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionInfo.java">InjectionInfo</a> and the derived types - specific to each injector - are simply responsible for instancing the correct <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/code/Injector.java">Injector</a> (which performs the actual manipulation) and handling any other injection-type-specific parsing actions.</p>
<p>The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionInfo.java">InjectionInfo</a> is responsible for parsing out the information from the injector annotation, and locating the candidate target methods for the injection based on the parsed data.</p>
<blockquote>
<p>It's important to note that during the <strong>Pre-Injection</strong> stage, all injectors perform their initial scan of the methods in the class in order to locate their target methods, and desired target opcodes opcodes within the the methods. The search must be completed for all injectors before injections begin in order to allow preservation of the semantics of <code>ordinal</code> and other code-sensitive operations. In early versions of Mixin, injectors were applied progressively, and opcodes altered by earlier injectors could alter the results of later ones. From version 0.5 onwards, injection is now performed in two passes.</p>
</blockquote>
<p>Parsing and discovery of targets begins by parsing out defined <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/code/MethodSlice.java">slices</a> into a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/code/MethodSlices.java">MethodSlices</a> holder. The slices themselves can be retrieved by ID when searching (though single-slice injectors will always use a fixed ID of <em>empty string</em>.</p>
<p>String references are first parsed out of the annotation into <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/MemberInfo.java">MemberInfo</a> structs, with the incoming strings being pumped through the config-specified <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/refmap/ReferenceMapper.java">ReferenceMapper</a> which uses the <code>refMap</code> generated at compile-time to convert the compiled-in strings to their obfuscated counterparts.</p>
<p>The parsed <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/MemberInfo.java">MemberInfo</a>s are then used as discriminators to locate matching methods in the class. Matching methods are added to an internal <code>targets</code> queue.</p>
<p>Finally, the declared injection points are parsed from the annotation into <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/InjectionPoint.java">InjectionPoint</a> instances which will be used later to match opcodes in the discoverd <code>targets</code>. The injector is now fully parsed and ready to be run.</p>
<h5>
<a aria-hidden="true" class="anchor" href="#preparing-the-injector" id="user-content-preparing-the-injector"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Preparing the Injector</h5>
<p>Once parsing is complete, the injector is checked for validity (that it has matched one or more targets) and is discarded from further processing if no targets were identified.</p>
<p>To run the discovery pass, the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionInfo.java">InjectionInfo</a> visits each of its queued <code>targets</code> and obtains a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a> wrapper for each.</p>
<blockquote>
<p><a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a> is a method wrapper obtained from the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/TargetClassContext.java">TargetClassContext</a> which keeps track - for all injectors - of changes made to the method by each injector. This allows aspects such as the max-stack and max-locals to be manipulated in a reliable manner without injectors needing to track this information themselves. It also - as we shall see below - allows injectors to observe the effects of other injectors and act accordingly.</p>
</blockquote>
<p>The parsed list of injection points, and the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a> is then fed into the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/code/Injector.java">Injector</a>'s <code>find</code> method, which runs the injection points on the target. Instead of storing the matched <em>ASM "Instruction Nodes" (<code>AbstractInsnNode</code>)</em> directly, the Injector wraps each discovered node in a <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/code/Injector.java#L65">TargetNode</a> which allows nodes to be decorated with their nominating injection points, for later reference. This process returns a list of unique nominee nodes to the Injector which represents the universe of instructions which are targetted.</p>
<p>Once the nominee nodes have been identified, they are submitted to the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a> which creates an <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionNodes.java#L53">InjectionNode</a> for each nominated node. The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionNodes.java#L53">InjectionNode</a> represents a unique handle to each underlying instruction which can track when the instruction is replaced by an injector.</p>
<p>The returned collection of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionNodes.java#L53">InjectionNode</a>s is then stored with the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a> in the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionInfo.java">InjectionInfo</a>, ready for application.</p>
<p>The final stage is to strip the injection annotations from the methods, since they are now fully parsed and are no longer required.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3333-injection-application-stage" id="user-content-3333-injection-application-stage"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.3.3 Injection Application Stage</h4>
<p>Now that all injectors have determined their target methods and nominee nodes, the final pass of applying the mixin is the actual <strong>Injection</strong> stage.</p>
<p>As you might imagine, the parsed <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionInfo.java">InjectionInfo</a>s from the previous pass are simply visited in order and allowed to inject their changes into each target. The <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/code/Injector.java">Injector</a> is called for each combination of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a> and nominee <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionNodes.java#L53">InjectionNode</a>s in order to perform its injection.</p>
<p>Importantly, any instruction <em>replacements</em> or <em>additions</em> made by injectors are marshalled through the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/Target.java">Target</a>, which decorates the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionNodes.java#L53">InjectionNode</a> with its replacement instruction if replaced. Later injectors can then decide dynamically whether they care that the instruction was replaced: for example an <code>@Redirect</code> injector can fail deterministically with a useful error; whereas an <code>@Inject</code> callback injector can happily proceed since even though the instruction was replaced, the <em>location</em> is still intact.</p>
<p>Injectors can also use the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/struct/InjectionNodes.java#L53">InjectionNode</a> to marshal metadata to each other. For example the <code>@Redirect</code> injector can respect priority semantics by decorating the injection node with its identity and priority. If it encounters a node which was previously redirected by an injector with lower priority, it can choose to usurp it, or throw an error if the previous injector was <code>@Final</code>. Metadata from the <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/injection/InjectionPoint.java">InjectionPoint</a> itself can also be propagated in this way.</p>
<h5>
<a aria-hidden="true" class="anchor" href="#populating-accessors" id="user-content-populating-accessors"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Populating Accessors</h5>
<p>In addition to processing the injectors, the final <strong>Injection</strong> stage also visits all <code>@Accessor</code> and <code>@Invoker</code> methods discovered during the <code>attach</code> phase of the preprocessor by generating relevant methods with the appropriate proxy instructions and appending them to the target class.</p>
<p>Much like injectors, accessors and invokers are first parsed into <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/gen/AccessorInfo.java">AccessorInfo</a> and <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/gen/InvokerInfo.java">InvokerInfo</a> respectively, and then the appropriate generator is constructed in a second pass which fabricates the method and adds it to the target class.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#3334-upgrade-stage" id="user-content-3334-upgrade-stage"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.3.3.4 Upgrade Stage</h4>
<p>Upgrading is a final pass over the mixin which deals with a problematic side effect of shadows and overwrites when combined with access transformers.</p>
<p><img alt="" src="https://github.com/SpongePowered/Mixin/raw/master/docs/images/how_07.png"/></p>
<p>In general, it is anticipated that the access modifiers of a <code>@Shadow</code> or <code>@Overwrite</code> are going to either match the target, or in the case of shadow methods be maybe more permissive (it's fully allowable to make a <code>protected abstract</code> shadow rather than a <code>private</code> one since it means the method body can be omitted). This means that in almost all cases, any <em>invocations</em> in the mixin of a <code>private</code> shadow method are going to use the correct <code>INVOKESPECIAL</code> opcode for the invocation.</p>
<p>However, consider the situation where an <em>Access Transformer</em> is used at runtime by a third party to increase the visibility of a base-class method from <code>private</code> to <code>protected</code> so that they can override the method in one of their own custom derived classes. If the mixin code were to silently proceed with its original <code>INVOKESPECIAL</code>, the override contract would be voided because the mixin code would still call the base-class method even in the derived class, because the <code>INVOKESPECIAL</code> would be statically-bound to the base class method and would not employ the vtable.</p>
<p>Mixin's <em>upgrade</em> functionality works around this by logging (at <code>attach</code> time) any methods which need to be "upgraded" from <code>private</code> to greater visibility to match their target, the final pass is then made over <em>all invocations in the target class</em> to ensure that the method is invoked using the correct opcode. This change is already made by the access transformer to incoming code and thus it is only mixin code which needs the upgrade performed.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#34-moving-to-a-new-phase" id="user-content-34-moving-to-a-new-phase"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>3.4 Moving to a New Phase</h2>
<p>If a new phase is triggered, processing once again returns to the preparation stage and the configs for the phase are ingested by the transformer. No state is released at this point, so existing configs, existing class metadata in the shape of <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/transformer/ClassInfo.java">ClassInfo</a> is not discarded. New configs are simply added to the state and processing continues as before.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#4-conclusions" id="user-content-4-conclusions"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>4. Conclusions</h1>
<p>Mixin might at first glance appear to take a simple job - smushing bytecode together - and make it complex by hanging everything in a large amount of unnecessary framework. However, most of the complexity effectively boils down to supporting the following key aspects of applying mixins successfully:</p>
<ul>
<li>
<p>Awareness of classes outside the scope of the mixin and its target is vital, this includes changes made to classes by other mixins allowing intra-mixin functionality to be a possibility</p>
</li>
<li>
<p>Storing sufficient class meta-information to provide awareness of changes made to classes so that they can be propagated throughout the incoming code; viz. prefixed shadows and soft-implemented methods.</p>
</li>
<li>
<p>Detecting and adapting to changes made by other transformers in the environment: running the transformer chain on incoming code is expensive but unavoidable</p>
</li>
<li>
<p>Specialising mixins to the context of their target is much more complex than "take code from mixin class and merge into target class", especially for aspects such as lamba functions (in Java, effectively anonymous methods) and invocations of methods in supermixins.</p>
</li>
<li>
<p>Scaffolding for other features, such as runtime exporting, bytecode validation, handling different obfuscation types, in-place auditing checks, and compatibility level adaptation all add additional layers of complexity and require careful management</p>
</li>
<li>
<p>Support for Injectors represents an entire subsystem of functionality which rides on the Mixin core.</p>
</li>
</ul>
<h2>
<a aria-hidden="true" class="anchor" href="#41-aspects-of-mixin-not-covered-in-this-article" id="user-content-41-aspects-of-mixin-not-covered-in-this-article"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>4.1 Aspects of Mixin Not Covered in This Article</h2>
<p>I have, unapologetically, omitted a few topics from this article because they would have bloated it without purpose. I will likely address them in future technical articles:</p>
<h3>
<a aria-hidden="true" class="anchor" href="#411-platform-handlers-and-platform-specific-functionality" id="user-content-411-platform-handlers-and-platform-specific-functionality"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>4.1.1 Platform Handlers and Platform-Specific Functionality</h3>
<p>Mixin doesn't exist in a vacuum. As a subsystem, mixin needs co-operation from the application framework in order to load and perform its functions. There is a not inconsiderable amount of functionality devoted in interacting with different target platforms in order to leverage mixin into the target environments. However given that these features are extremely platform-specific and don't pertain to Mixin's own operations beyond bootstrapping, I have omitted them from discussion in this article.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#412-the-annotation-processor" id="user-content-412-the-annotation-processor"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>4.1.2 The Annotation Processor</h3>
<p>A huge part of Mixin as a framework, as discussed in the previous introduction-series article "<a href="https://github.com/SpongePowered/Mixin/wiki/Introduction-to-Mixins---Obfuscation-and-Mixins">Introduction to Mixins - Obfuscation in Mixins</a>", is the need to traverse the obfuscation boundaries presented by development-time versus production-time. The agent responsible for this traversal is the Mixin <em>Annotation Processor</em> which acts at compile-time to produce the required data for mixins to successfully operate in an obfuscated environment.</p>
<p>Though I touched on the <em>output</em> of this system when mentioning <a href="https://github.com/SpongePowered/Mixin/blob/master/src/main/java/org/spongepowered/asm/mixin/refmap/ReferenceMapper.java">ReferenceMapper</a> above, discussion of the AP itself is outside the scope of this article.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#413-auditing-functionality" id="user-content-413-auditing-functionality"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>4.1.3 Auditing Functionality</h3>
<p>Various aspects of Mixin's operation are designed to provide development-time quality-of-life improvements to mixin authors. In particular exporting and live-decompiling of postprocessed bytecode is a core feature of Mixin, as well as user-enabled modules to run ASM's <code>CheckClassAdapter</code> and to audit the implementation of particular interfaces which are being mixed-in.</p>
<p>Since these parts of the mixin core do not directly pertain to the application of mixins, I have omitted them for clarity.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#42-a-final-word" id="user-content-42-a-final-word"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>4.2 A Final Word</h2>
<p>Mixin is constantly evolving, and my goal with Mixin is to stick to the core principles outlined above, in particular to <em>do no harm</em>. Nearly all of the framework surrounding the Mixin core is to enable it to do its job reliably and efficiently. Whilst this ultimately increases the complexity of Mixin as a whole, I believe that preserving the effectiveness of the system overall is worth this trade-off. I hope I have successfully demonstrated that everything Mixin does, it does for a reason, and that my motives are altruistic.</p>
<p>If you made it this far, congratulations. Put your comments on the back of postcard and come visit <code>#spongedev</code> on espernet to say "hi".</p>

        </div>

    </div>]